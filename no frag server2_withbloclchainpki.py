import base64
import json
import random
from base64 import b64encode, b64decode
from Crypto.Cipher import ChaCha20_Poly1305
from scapy.all import *
from scapy.layers.inet import IP
import ast
from harakav2 import pad_message, haraka512256
from falcon import falcon
from QRNG_6QUBIT import QRNG_GEN
import numpy as np
from NTRU import ntru
from CA_CONNECTION import request_handler

# Load pre-calculated keys
data_server = np.load('server_cert.npy', allow_pickle='TRUE').item()
pub_key = data_server['pub_key_s_h']
priv_key_sf = data_server['sk_f']
priv_key_sg = data_server['sk_g']

print("pub_key_s_h ", pub_key)
print("priv_key_sf ", priv_key_sf)
print("priv_key_sg ", priv_key_sg)

# Initialize NTRU
Challenge = ntru.Ntru(7, 29, 491531)
Challenge.genPublicKey(priv_key_sf, priv_key_sg, 2)

# Server configuration
server_ip = "192.168.68.139"
server_port = 4449


class EncryptedTCP(Packet):
    name = "EncryptedTCP"
    fields_desc = [
        StrFixedLenField("sport", b"\x00\x00\x00\x00\x00", 5),
        StrFixedLenField("dport", b"\x00\x00\x00\x00\x00", 5),
        IntField("seq", 0),
        IntField("ack", 0),
        BitField("dataofs", None, 4),
        BitField("reserved", 0, 3),
        FlagsField("flags", 0x2, 9, "FSRPAUECN"),
        ShortField("window", 8192),
        XShortField("chksum", None),
        ShortField("urgptr", 0),
        PacketListField("options", []),
    ]


bind_layers(IP, EncryptedTCP, proto=99)


def sign_fn(payload, server_qrng, header, client_qrng):
    cipher = ChaCha20_Poly1305.new(key=shared_secret, nonce=server_qrng)
    cipher.update(header)
    secret_key_sign = falcon.SecretKey(32)
    public_key_sign = falcon.PublicKey(secret_key_sign)
    sign_str = secret_key_sign.sign(payload)
    pk_arr = public_key_sign.h
    pk_arr = struct.pack('>' + 'h' * len(pk_arr), *pk_arr)
    payload = payload + b"<|>" + sign_str + b"<|>" + pk_arr + b"<|>" + client_qrng

    ciphertext, tag = cipher.encrypt_and_digest(payload)
    jk = ['nonce', 'header', 'ciphertext', 'tag']
    jv = [b64encode(x).decode('utf-8') for x in (server_qrng, header, ciphertext, tag)]
    result = json.dumps(dict(zip(jk, jv)))
    return result


def check_signature(payload, client_qrng_old):
    try:
        b64 = json.loads(payload)
        jk = ['nonce', 'header', 'ciphertext', 'tag']
        jv = {k: b64decode(b64[k]) for k in jk}

        if jv['nonce'] == client_qrng_old:
            print("NONCE VERIFIED FROM CLIENT")
        else:
            print("ERROR: MESSAGE COULD BE TAMPERED")
            return None, False, None

        cipher = ChaCha20_Poly1305.new(key=shared_secret, nonce=jv['nonce'])
        cipher.update(jv['header'])
        plaintext = cipher.decrypt_and_verify(jv['ciphertext'], jv['tag'])

        blockhash, sign_str, pk_arr = plaintext.split(b'<|>')
        sign_str = bytes(sign_str)
        print("Decrypted hash: ", blockhash)

        pk_fn = falcon.PublicKey(n=32, h=list(struct.unpack('>' + 'h' * (len(pk_arr) // 2), pk_arr)))
        check = pk_fn.verify(blockhash, bytes(sign_str))
        print("Verification status: " + str(check))

        return blockhash, check, None
    except (ValueError, KeyError):
        print("Incorrect decryption")
        return None, False, None


from scapy.all import *
import time

def send_with_timeout(pkt, filter_str, timeout=10, retry=1):
    for _ in range(retry + 1):  # Original attempt + retry
        ans = sr1(pkt, timeout=timeout, verbose=0)
        if ans is not None:
            return ans
        print(f"No response received within {timeout} seconds. Retrying...")
    print("No response received after retry. Continuing...")
    return None

# Main server logic
print("Server initializing...")
Bob = ntru.Ntru(7, 29, 491531)
Bob.genPublicKey(priv_key_sf, priv_key_sg, 2)
pub_key = Bob.getPublicKey()
print("Public Key Generated by Server: ", pub_key)

# Wait for client connection
syn = sniff(filter=f"ip and host {server_ip}", count=1)[0]
client_ip = syn[IP].src
ip_pkt = IP(dst=client_ip, proto=99)

# Complete TCP handshake
syn_ack = ip_pkt / EncryptedTCP(flags="SA", ack=syn.seq + 1)
ack = sr1(syn_ack)
print("TCP Handshake successful")

# Send public key to client
params = ','.join(map(str, [Bob.N, Bob.p, Bob.q])).encode()
pub_bytes = str(pub_key)
msg1 = params + b'|' + bytes(pub_bytes.encode())
pkt1 = ip_pkt / EncryptedTCP(flags="PA") / msg1
send(pkt1)

# Receive client's encrypted message
reply1 = sniff(filter=f"ip and host {server_ip}", count=1)[0]
if len(reply1[Raw].load) > 0:
    print("Received ciphertext from client")
    decrypt_msg = Bob.decrypt(ast.literal_eval(reply1[Raw].load.decode("UTF-8")))
    print("Decrypted Message: ", decrypt_msg)

    # Generate shared secret
    decrypt_msg = pad_message(bytes(decrypt_msg))
    shared_secret = bytes(haraka512256(decrypt_msg))
    print("Shared Secret: ", shared_secret)

    # Generate two nonces
    server_qrng = QRNG_GEN("server nonce")
    client_qrng = QRNG_GEN("client nonce")
    print("Server nonce: ", server_qrng)
    print("Client nonce: ", client_qrng)

    # Send server's public key hash and client's nonce
    msg2 = json.dumps(data_server['pub_key_s_h'])
    msg2 = bytes(msg2, 'utf-8') + b"|" + client_qrng
    msg2 = sign_fn(msg2, server_qrng, header=b"server_hash", client_qrng=client_qrng)
    pkt2 = ip_pkt / EncryptedTCP(flags="PA") / msg2
    send(pkt2)

    # Receive client's challenge
    client_challenge = sniff(filter=f"ip and host {server_ip}", count=1)[0]
    client_challenge_data = json.loads(client_challenge[Raw].load)
    print("Received challenge data:", client_challenge_data)

    # Decode the Base64 string to bytes
    encrypted_challenge_bytes = base64.b64decode(client_challenge_data['ciphertext'])

    # Convert the bytes back to a list of integers
    encrypted_challenge = list(struct.unpack(f'>{len(encrypted_challenge_bytes) // 4}I', encrypted_challenge_bytes))

    decrypted_challenge = Challenge.decrypt(encrypted_challenge)
    decrypted_challenge_sum = decrypted_challenge[0]
    expected_sum = client_challenge_data.get('sum')
    print(f"Decrypted Challenge: {decrypted_challenge}")
    print(f"Decrypted Challenge sum: {decrypted_challenge_sum}, Expected sum: {expected_sum}")

    if expected_sum is not None and decrypted_challenge_sum == expected_sum:
        print("Successfully decrypted and verified client's challenge")
    else:
        print("Failed to verify client's challenge")
        print(f"Decrypted sum: {decrypted_challenge_sum}, Expected sum: {expected_sum}")
        # exit()

    # Solve and send response to client's challenge
    challenge_solution = [decrypted_challenge_sum]
    print("Calculated solution:", challenge_solution)
    encrypted_solution = Challenge.encrypt(challenge_solution, [-1, -1, 1, 1])

    # Convert the encrypted solution to Base64
    encrypted_solution_bytes = struct.pack(f'>{len(encrypted_solution)}I', *encrypted_solution)
    encrypted_solution_base64 = base64.b64encode(encrypted_solution_bytes).decode('utf-8')

    print("Encrypted solution:", encrypted_solution_base64)
    solution_str = json.dumps({'ciphertext': encrypted_solution_base64})
    pkt_solution = ip_pkt / EncryptedTCP(flags="PA") / solution_str
    send(pkt_solution)
    # Send server's challenge to client
    server_challenge = [2, 3, 1, 4]
    print("Server's Challenge: ", server_challenge)
    encrypted_server_challenge = Challenge.encrypt(server_challenge, [-1, -1, 1, 1])
    server_challenge_str = json.dumps({'ciphertext': str(encrypted_server_challenge)})
    pkt_server_challenge = ip_pkt / EncryptedTCP(flags="PA") / server_challenge_str
    send(pkt_server_challenge)

    # Receive and verify client's solution
    client_solution = sniff(filter=f"ip and host {server_ip}", count=1)[0]
    client_solution_data = json.loads(client_solution[Raw].load)
    decrypted_client_solution = Challenge.decrypt(ast.literal_eval(client_solution_data['ciphertext']))
    if decrypted_client_solution[0] == 24:  # 2 * 3 * 1 * 4 = 24
        print("Client successfully solved the challenge")
    else:
        print("Client failed to solve the challenge")
        # exit()

    # Receive client's hash
    msg3 = sniff(filter=f"ip and host {server_ip}", count=1)[0]
    client_hash, verif, _ = check_signature(msg3[Raw].load, client_qrng_old=client_qrng)

    if verif:
        print("Client hash verified")
        print("PKI HASH VERIFICATION STATUS ",
              request_handler.get_request(server_pub=client_hash, ip_pkt=ip_pkt, server_ip="192.168.0.18"))
    else:
        print("Client hash verification failed")
        # exit()

    # Send acknowledgment
    pkt3 = ip_pkt / EncryptedTCP(flags="A")
    send(pkt3)
    print("Challenge-response completed, starting communication with client")

    # Main communication loop
    while True:
        msg4 = sniff(filter=f"ip and dst {server_ip} and src {client_ip}", count=1)[0]

        if msg4[EncryptedTCP].flags in ["F", "FA"]:
            print("Finalizing connection")
            fin_ack = IP(dst=client_ip) / EncryptedTCP(flags="FA")
            send(fin_ack)
            break

        client_msg, verif, _ = check_signature(payload=msg4[Raw].load, client_qrng_old=client_qrng)
        if verif:
            reply = f"Server received: {client_msg.decode('UTF-8')}"
            print("replying")
            reply = sign_fn(payload=reply.encode(), server_qrng=server_qrng,
                            header=b"server_reply", client_qrng=client_qrng)
            pkt_reply = IP(dst=client_ip) / EncryptedTCP(flags="PA") / reply
            send(pkt_reply)
        else:
            print("Failed to verify client message")

else:
    print("Error: No data received from client")